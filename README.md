# JAVA-SPRING
자바, 스프링 공부
## JAVA
### Singleton pattern
- 하나만 존재해야하는 객체를 만들때 사용
- instance 를 저장할 static 변수 하나 선언
- new instance
- getInstance 로 객체 주소값 리턴
- 이러한 방식으로 객체를받는 예 -> 캘린더(날짜는 딱 하나만 존재해야함)


### Factory Method Pattern
- 객체간 연관성을 줄일려고 쓰는것 같음
- 아직 잘 모르겠음

### Templete Method Pattern
- 객체의 흐름은 이미 정의되어 있음, 구현만 각자 알아서 해서 사용
- 추상클래스 안에 공통적인 부분은 일반 메서드로 구현하고 하위클래스 마다 다른 기능은 추상메서드를 활용하여 선언
- 하위 클래스는 시나리오대로 구현만 할 뿐
- 프레임워크의 개념을 몰랐는데 비슷한 개념임

### Strategy Pattern
- 인터페이스를 활용하면 다양한 정책이나 알고리즘을 프로그램은 큰 수정없이 적용 확장 할 수 있음

### 상속
- A : 부모객체, B : 자식객체
- A a = new B() => 업캐스팅 가능
- 힙 메모리 구조는 부모객체 생성자가 먼저 호출되어 할당되고 자식객체 생성자가 호출되어 할당
- a.method() : 재정의 된 메서드는 b 메서드 호출, 재정의 안된 메서드는 a 메서드 호출
- 하나의 메서드는 고유한 주소를 가짐, 동일한 이름의 메서드는 존재할수 없음(오버로딩은 이름이 조금씩 바뀜)
- 오버라이딩시 가상함수로 새로운 주소로 할당

- IS-A 관계 : 동물 >>> 사람 >>> 호랑이, 추상적인것이 구체화되는경우
- HAS-A 관계 : 학생 >>> 과목, 객체가 객체를 소유한경우

### 다형성
- 동물클래스에서 사람, 호랑이, 새 클래스를 상속한경우 자료형을 동물 인스턴스를 사람, 호랑이, 새 로하면 하나의 자료형으로 다른 결과를 얻어 낼 수 있음으로 다형성이다.
- 다형성이 있음으로서의 장점 : 사람 호랑이 새 인스턴스를 동물이라는 자료형 하나로 다룰 수 있다, 만약 다형성이 없다면 우리는 매서드 안에 수많은 if 문을 사용하여 인스턴스를 구분해야 할것이다.

### 다운캐스팅
- 업캐스팅한 인스턴스를 다시 다운캐스팅 할 수 있음
- instanceof 키워드를 사용하는것이 바람직 ex> if(animal instanceof human){ Human human = (Human)animal; human.readBooks();}
- 다운캐스팅은 오버라이딩이 불가피한경우 사용하는것이 좋다

### static
- 공유의 개념, 메모리를 중복해서 할당하지 않고 같은 주소를 참조함

### final
- 변수 : 값이 변하지 않음
- 메서드 : 오버라이딩 불가
- 클래스 : 상속 불가능

### interface
- 인터페이스는 명세다
- JDBC를 예로 들면, 자바에서 Connection 이라는 인터페이스를 만들어 놓으면 Oracle, Mysql, MongoDB등 이런 회사에서 자기 디비에 맞는 코드로 인터페이스를 구현하고 클라이언트들은 그냥 그 내부적인 소스를 이해하고 사용하는게 아니라 자바가 선언한 인터페이스만을 보고 사용하는거임.
- 설계에서 아주 중요한 개념, 추상클래스와의 차이는 명세, 그리고 모든 메소드가 다 추상메소드 라는점(추상클래스는 일부만 추상 메소드)
- 인터페이스에서의 변수는 상수에 해당한다

### Object Class
- toString : 스트링 클래스를 System.out.println(str)하면 Obejct.String@adress 가 나오는게 아니라 문자열이 출력됨
- 내부적으로 str이 str.toString()으로 바뀌기 때문
- Student(String name, String num) 이라는 클래스는 Obejct.String@adress 방식으로 출력이 되기 때문에 오버라이딩을 해서 사용 해야함

- equals : 마찬가지로 스트링클래스를 똑같은지 비교하면 다른 주소이지만 동일한 문자열을 가지는 경우 동일하다고 판단함
- 위의 스튜던트 클래스는 동일하다고 판단을 못하기 때문에 마찬가지로 오버라이딩 해서 내가 원하는 결과가 나오도록 만들어 줌
- 구현시 insteadof 를 사용하여 오브잭트 클래스를 다운캐스팅 해주고 매개변수와 멤버변수를 사용하여 구현

- 두 객체가 같다 라고 판단할때 equals로 논리적으로 같아야함을 확인해야하고, hashCode 리턴값이 같음을 확인해야한다. 해쉬코드는 보통 학생의 경우 학번 과 같은 고유한값을 사용한다

- clone : 한개의 프로토타입 객체를 복사할때 주로 사용, 마찬가지로 오버라이딩 하여야하며, Cloneable 인터페이스도 상속 받아야함, 또한 클론시 오브젝트 클래스에서 우리가 원하는 클래스 타입으로 현 변환도 해 주어야 함

- finalized : 가비지 콜랙터에서 호출하는 함수로 우리가 호출하지 않음, 열려있는 소켓같은걸 닫는 함수

### String
- String 은 불변, 값이 바뀔수 없기때문에 concat(문자열 수정)을하는경우 새로운 메모리에 스트링이 할당됨
- StringBuilder : 가변 스트링, 기존의 메모리에서 스트링을 수정할 수 있음,(멀티스레드 환경에서 동기화 안됨), 단일스레드에서 사용
- StringBuffer : 가변 스트링, 기존의 메모리에서 스트링을 수정할 수 있음, 멀티스레드 환경에서 동기화 됨

### Wrapper Class
- int -> Integer 등등.. 오토 박싱 언박싱이라 자유롭게 사용가능


### Collection Framework
- 미리 자료구조를 정의해 놓고 코딩을 편하게 사용, Collection은 하나의 객체에 대한 자료구조이고 Map은 두개읭 객체에 대한 자료구조이며 key Value로 정의되는데, 내생각엔 NoSQL 도 키벨류로 되어있으니 그거를 사용하려고 만든 자료구조 같음


### 제네릭 프로그래밍
- C++의 템플릿과 유사한 개념, 클래스 명 뒤에<T>를 쓰거나 public static <T,V> int method(Point<T,V> p1) 와같은 방식으로 사용 <T,V>는 지역변수 개념이라 클래스 옆 <T>와는 아에 다른 제네릭변수

### 내부 클래스
- 인스턴스 내부 클래스 : 인스턴스변수와 동일한 위치
- static 내부 클래스 : 스태택변수와동일
- 지역 내부 클래스 : 메서드 안에 위치
- 익명 내부 클래스 : 함수 이름 없이 바로사용(안드로이드에서 많이사용)

### 람다식
- 람다식이란? 함수형 프로그래밍, 매개변수만 사용하고 외부변수에 영향을 주지 않기 때문에 사이드 이펙트가 없음 -> 따라서 병렬처리 등 안정성 있는 확장을 보장한다
- 인터페이스 선언하고 하나의 추상메서드를 선언, 매개변수->{ return (x >= y)?x:y; } 이런 형태로 사용함
- 기존에 인터페이스를 상속받아서 그 상속받은 클래스를 구현하고 클래스 생성자를 생성해서 사용하는거와는 대조적이다.
